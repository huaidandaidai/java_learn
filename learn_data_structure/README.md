# Java数据结构和算法

## leetcode算法题
### ConstantPool 
**用JVM知识解释运行结果**

JDK1.6版本  运行结果为false；
          JDK1.8版本  运行结果为true；       
          结果原因：
          1、intern()的方法为返回常量池中包含此方法调用者相同值的引用，若常量池中不存在，则复制一份并返回其引用。
          2、String +操作，底层为StringBuilder类new出的新对象。
          3、1.6版本中常量池在JVM运行时数据区中的方法区。c的引用对象在堆中，常量池找不到对应的值，所以在常量池中新建了一份值，并返回其引用，所以结果为false。
          4、1.8版本中常量池移动到了堆中，intern方法在整个堆中查找值。所以返回结果为true。

## java中的集合类

## enjoy 享学课堂中的作业和代码

## 位运算[位运算](https://blog.csdn.net/black_bird_cn/article/details/80171652)
**^(异或运算)** 针对二进制，相同的为0，不同的为1
``public static void main(String[] args) {
      System.out.println("2^3运算的结果是 :"+(2^3));
      //打印的结果是:   2^3运算的结果是 :1
  }``
  2 =======>0010 
  3 =======>0011  
  2^3======>0001，结果就是1

**&(与运算)**  针对二进制，只要有一个为0，就为0
  2 =======>0010 
  3 =======>0011  
  2&3======>0010，结果就是2

**<<(向左位移)** 针对二进制，转换成二进制后向左移动3位，后面用0补齐
  2 =======>0010 
  2<<3======>0001 0000，结果就是16(1*2的4次方)

**>>(向右位移)** 针对二进制，转换成二进制后向右移动3位
  2 =======>0010 
  2>>3======>0000(去掉010，右边用0补齐)，结果就是0

**>>>(无符号向右位移)**

##  缓存淘汰机制
**内存缓存**：预先将数据写到了容器之中等数据存储单元，就是软件内存缓存；

**内存缓存淘汰机制**：[内存淘汰机制](https://blog.csdn.net/youanyyou/article/details/78989956)
 1. FIFO (First In ,First Out)  先进先出；如果一个数据最先进入缓存，则应该最早淘汰掉。
 2. LFU  (Least Frequently Used) 最不频繁使用的；使用一个计数器来记录条目被访问的频率，最低访问数的条目最先被移除。
 3. LRU  (Least Recently Used)   最近使用最少的;将最近使用的条目存放到缓存的顶端，当缓存达到极限后，条目从底部开始移除。
 
 **LRU算法实现**：
 
 ![示例图](https://github.com/huaidandaidai/java_learn/blob/master/learn_data_structure/src/org/lsh/lru/LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6.jpg)
 1. 新数据插入到链表头部；
 2. 当缓存命中（即缓存数据被访问），数据要移动到表头。
 3. 当链表满时将尾部的数据丢弃掉。
 
 ## 队列实现
 **实现原理**：
 1. 队列的特性：先进先出，后进后出。
 2. 实现方式：数组、链表.
 
 ## 栈实现
 **实现原理**：
  1. 栈的特性：先进后出，后进先出。
  2. 实现方式：数组、链表.