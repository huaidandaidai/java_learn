# Java数据结构和算法

## leetcode算法题
### ConstantPool 
**用JVM知识解释运行结果**

JDK1.6版本  运行结果为false；
          JDK1.8版本  运行结果为true；       
          结果原因：
          1、intern()的方法为返回常量池中包含此方法调用者相同值的引用，若常量池中不存在，则复制一份并返回其引用。
          2、String +操作，底层为StringBuilder类new出的新对象。
          3、1.6版本中常量池在JVM运行时数据区中的方法区。c的引用对象在堆中，常量池找不到对应的值，所以在常量池中新建了一份值，并返回其引用，所以结果为false。
          4、1.8版本中常量池移动到了堆中，intern方法在整个堆中查找值。所以返回结果为true。

## java中的集合类

## enjoy 享学课堂中的作业和代码

## 位运算[位运算](https://blog.csdn.net/black_bird_cn/article/details/80171652)
**^(异或运算)** 针对二进制，相同的为0，不同的为1
``public static void main(String[] args) {
      System.out.println("2^3运算的结果是 :"+(2^3));
      //打印的结果是:   2^3运算的结果是 :1
  }``
  2 =======>0010 
  3 =======>0011  
  2^3======>0001，结果就是1

**&(与运算)**  针对二进制，只要有一个为0，就为0
  2 =======>0010 
  3 =======>0011  
  2&3======>0010，结果就是2

**<<(向左位移)** 针对二进制，转换成二进制后向左移动3位，后面用0补齐
  2 =======>0010 
  2<<3======>0001 0000，结果就是16(1*2的4次方)

**>>(向右位移)** 针对二进制，转换成二进制后向右移动3位
  2 =======>0010 
  2>>3======>0000(去掉010，右边用0补齐)，结果就是0

**>>>(无符号向右位移)**

##  缓存淘汰机制
**内存缓存**：预先将数据写到了容器之中等数据存储单元，就是软件内存缓存；

**内存缓存淘汰机制**：[内存淘汰机制](https://blog.csdn.net/youanyyou/article/details/78989956)
 1. FIFO (First In ,First Out)  先进先出；如果一个数据最先进入缓存，则应该最早淘汰掉。
 2. LFU  (Least Frequently Used) 最不频繁使用的；使用一个计数器来记录条目被访问的频率，最低访问数的条目最先被移除。
 3. LRU  (Least Recently Used)   最近使用最少的;将最近使用的条目存放到缓存的顶端，当缓存达到极限后，条目从底部开始移除。
 
 **LRU算法实现**：
 
 ![示例图](https://github.com/huaidandaidai/java_learn/blob/master/learn_data_structure/src/org/lsh/lru/LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6.jpg)
 1. 新数据插入到链表头部；
 2. 当缓存命中（即缓存数据被访问），数据要移动到表头。
 3. 当链表满时将尾部的数据丢弃掉。
 
 ## 队列实现
 **实现原理**：
 1. 队列的特性：先进先出，后进后出。
 2. 实现方式：数组、链表.
 
 ## 栈实现
 **实现原理**：
  1. 栈的特性：先进后出，后进先出。
  2. 实现方式：数组、链表.
  
  ## 树
  
  ### 树的常用基本术语
  **结点的度**:结点的子树个数
  **树的度**:树中所有结点中最大的度
  **叶结点**:度为0的结点
  
  ### 哈夫曼树(HuffmanTree)
  
  ### 二叉树
  `度为2的树`
  
  #### 二叉查找树(BST,Binary Sort Tree)[演示页面](https://www.cs.usfca.edu/~galles/visualization/BST.html)
  
  **特点**
  1. 左子树的所有值小于根节点的值
  2. 右子树的所有值大于根节点的值
  3. 左右子树满足以上两点
  
  **find逻辑(查询逻辑)**
  查找的值X从根节点开始
  1. 如果X小于根节点值，则在左子树中继续查找
  2. 如果X大于根节点值，则在右子树中继续查找
  3. 如果X值等于根节点的值，则返回该节点
  4. 如果都查不到则，返回null
  
  **Insert逻辑**
  插入的值X从根节点开始查找
  1. X值小于该节点的值，在左子树中继续;
  2. X值大于该节点的值，在右子树中继续;
  3. 如果节点是叶子节点，X值小于该节点则插入左节点，否则插入右节点中。
  
  #### 平衡二叉树
  左右两个子树的高度差的绝对值不超过1，目的是使得树的高度最低，因为树的查找效率取决于树的高度。
  **二叉平衡树的调整**:平衡二叉树插入或删除会有两个结果：平衡没被打破，不用调整；平衡被打破，需要调整。
  1. LL
  2. RR
  
  ## 图
  
  ### 定义
   ``图是由顶点(Vertex)和边(edge)组成的一种结构。顶点的集合V，边的集合是E，所以图记为G=(V,E)``
  
  ### 图的分类
  **无向图**
  **有向图**
  
  **连通图**
  **非连通图**
  
  ### 图的存储结构
  **邻接矩阵(二维数组)**
  
  ## 多线程
  
  ### 线程和进程的区别
  1. 进程是分配资源的最小单位(包括CPU/内存等)
  2. 线程是依赖于进程而存在的，是CPU执行的最小单元
  
  ### 线程的实现方式
  1. 继承Thread类（jdk官方方法之一）
  2. 实现Runnable接口(jdk官方方法之一)
  3. 接口callable(有返回值的)
  
  ### 线程的状态(jdk)
  1. new （新建）
  2. runnable(运行)
  3. blocked(阻塞)
  4. waiting(等待)
  5. timed_waitinbg
  6. terminated(结束)
  
    New ——> runnable ——>terminated
           //   ||   \\
          //    ||    \\
     blocked waiting  timed_waiting
  
  ### 线程的中断方法
  1. stop():已经被废弃，此方法会强制的中止线程，终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。
  2. suspend():在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题.
  3. interrupt():不会主动中断线程，只是将中断标志位置为true；
  4. isInterrupted()：检查中断标志位
  5. static isInterrupted():检查中断标志是否为true，若为true执行方法，并将标志置为flase。
  
  ### 线程池
  
  #### 线程池参数
  
  ### 并发工具
  
  
  